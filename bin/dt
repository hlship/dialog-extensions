#!/usr/bin/env joker

;; dt - Dialog Tool

(ns dt
  (:require
   [joker.tools.cli :as cli]
   [joker.os :as os]
   [joker.string :as str]
   [joker.filepath :as fp]))

(defn mkdirs 
  [path mode]
  (let [[dir _] (fp/split path)]
    (when-not (= path dir)
      (mkdirs dir mode))
    (os/mkdir path mode)))

(defmacro cond-let
  [& clauses]
  (cond (empty? clauses)
        nil

        (not (even? (count clauses)))
        (throw (ex-info (str `cond-let " requires an even number of forms")
                        {:form &form
                         :meta (meta &form)}))

        :else
        (let [[test expr-or-binding-form & more-clauses] clauses]
          (if (= :let test)
            `(let ~expr-or-binding-form (cond-let ~@more-clauses))
            ;; Standard case
            `(if ~test
               ~expr-or-binding-form
               (cond-let ~@more-clauses))))))

(defn show-errors
  [errors]
  (when (seq errors)
    (println)
    (println (if (= 1 (count errors)) "Error:" "Errors:"))
    (doseq [e errors]
      (println (str "  " e)))))

(defn extract-command-map
  "Returns map of command name (string) to var"
  []
  (->> (find-ns 'dt)
       ns-map
       (reduce (fn [m [sym v]]
                 (if (-> v meta :command)
                   (assoc m (name sym) v)
                   m))
               {})))

(defn show-help
  [errors]
  (let [m (extract-command-map)
        ks (-> m keys sort)
        width (+ 2 (apply max (map count ks)))]
    (println "Usage: dt COMMAND")
    (println)
    (println "Commands:")
    (doseq [k ks
            :let [doc-string (-> m (get k) meta :doc)
                  first-doc (-> doc-string str/split-lines first)]]
      (println (str (str/pad-left k " " width) ": " first-doc))))
  (show-errors errors))

(defn show-summary
  [parsed-opts errors]
  (let [{:keys [command-name summary args-desc doc]} parsed-opts]
    (apply println
           (remove nil? ["Usage: dt" command-name
                         "[OPTIONS]"
                         (when args-desc args-desc)]))
    (when doc
      (println doc))
    (println "\nOptions:")
    (println summary)
    (show-errors errors)))

(defn ^:command help
  "Lists available commands"
  [_]
  (show-help nil))

;; DT utilities
(defn fail 
  [msg]
  (println-err msg)
  (os/exit -1))

(defn read-build-file
  []
  (when-not (os/exists? "dialog.edn")
    (fail "No dialog.edn file in current directory."))
  
  (-> "dialog.edn"
      slurp
      read-string))

;; Commands


(defn do-build
  [build-data for-release?]
  (let [{:keys [output-format
                story-sources
                debug-sources
                library-sources]
         output-name :name} build-data
        output-dir (str "out/"
                        (if for-release? "release" "test"))
        output-path (str output-dir
                         "/"
                         output-name
                         "."
                         (name output-format))
        sources (reduce into []
                        [story-sources
                         (when-not for-release?
                           debug-sources)
                         library-sources])
        _                         (mkdirs output-dir 0766)
        result (os/exec "dialogc"
                        {:stdout *out*
                         :stderr *err*
                         :args (into ["-t" (name output-format)
                                      "-v" 
                                      "-o" output-path]
                                     sources)})]
        (when-not (:success result)
          (fail (str "Compiled failed: " (:err-msg result))))
        
        output-dir))

(defn ^:command
  build
  "Builds a releasable version of the story."
  [_]
  (do-build (read-build-file) false) )

;; Main "entry point":

(let [[command-name & command-args] *command-line-args*]
  (try
    (cond-let

     (or (nil? command-name)
         (str/starts-with? command-name "-"))
     (show-help ["No command provided"])

     :let [command-map (extract-command-map)
           command-var (get command-map command-name)]

     (nil? command-var)
     (show-help [(format "'%s' is not a command" command-name)])

     :let [{:keys [command-opts args-desc doc]
            :or {command-opts []}} (meta command-var)
           parsed-opts (assoc (cli/parse-opts command-args
                                              (conj command-opts ["-h" "--help" "This command summary"]))
                              :command-name command-name
                              :args-desc args-desc
                              :doc doc)
           {:keys [options errors arguments]} parsed-opts]

     (:help options)
     (show-summary parsed-opts nil)

     (seq errors)
     (show-summary parsed-opts errors)

     (and (nil? args-desc) (seq arguments))
     (show-summary parsed-opts [(str command-name " command does not take additional arguments")])

     :else
     (command-var parsed-opts))
    (catch Error t
      (println-err "Command failed:" (ex-message t))
      (when-let [data (ex-data t)]
        (binding [*out* *err*]
          (pprint data))))))