#!/usr/bin/env joker

;; dgt - Dialog Tool

(ns-sources
 {"net.lewisship.multi" {:url "https://raw.githubusercontent.com/hlship/multi/v1.0.0/src/net/lewisship/multi.joke"}})

(ns dgt
  (:require
   [joker.os :as os]
   [joker.string :as str]
   [joker.filepath :as f]
   [joker.time :as t]
   [net.lewisship.multi :as multi]))

(def failures-path "out/failures.edn")

(def csi "\u001b[")
(def reset-font (str csi "m")) 
(def red-font (str csi "31m"))
(def green-font (str csi "32m"))

;; Utilities
(defn fail
  [msg]
  (println-err msg)
  (os/exit -1))

(defn check-result
  [label result]
  (when-not (:success result)
    (fail (str label " failed: " (:err-msg result))))
  result)

(defn mkdirs
  "Recursively create a directory, if it doesn't already exist."
  [path]
  (check-result "mkdirs"
                (os/sh "mkdir" "-p" path)))

(defn rm
  [path]  
  (when (os/exists? path)
    (check-result "Remove" 
                  (os/sh "rm" path))))

(defmacro cond-let
  [& clauses]
  (cond 
    (empty? clauses)
    nil

    (not (even? (count clauses)))
    (throw (ex-info (str `cond-let " requires an even number of forms")
                    {:form &form
                     :meta (meta &form)}))

    :else
    (let [[test expr-or-binding-form & more-clauses] clauses]
      (if (= :let test)
        `(let ~expr-or-binding-form (cond-let ~@more-clauses))
            ;; Standard case
        `(if ~test
           ~expr-or-binding-form
           (cond-let ~@more-clauses))))))

;; Commands library

;; DGT Commands

(defn read-build-file
  []
  (when-not (os/exists? "dialog.edn")
    (fail "No dialog.edn file in current directory."))
  
  (-> "dialog.edn"
      slurp
      read-string))

;; Commands


(defn extract-sources
  [build-data for-release?]
  (let [{:keys [story-sources
                debug-sources
                library-sources]} build-data]
    (reduce into []
            [story-sources
             (when-not for-release?
               debug-sources)
             library-sources])))

(defn do-build
  [build-data for-release?]
  (let [{:keys [output-format]
         output-name :name} build-data
        output-dir (str "out/"
                        (if for-release? "release" "test"))
        output-path (str output-dir
                         "/"
                         output-name
                         "."
                         (name output-format))
        sources (extract-sources build-data for-release?)]
    (mkdirs output-dir)
    (check-result "Compile" 
                  (os/exec "dialogc"
                           {:stdout *out*
                            :stderr *err*
                            :args (into ["-t" (name output-format)
                                         "-v"
                                         "-o" output-path]
                                        sources)}))

    output-dir))

(defn ^:command
  build
  "Builds a releasable version of the story"
  [_]
  (do-build (read-build-file) false))

(defn ^:command
  clean
  "Cleans output"
  [_]
  (check-result "Delete"
                (os/sh "rm" "-rf" "out")))

(defn find-test-paths
  []
  (let [result (os/sh "find" "tests" "-name" "*.txt")]
    (check-result "Find" result)  
    (->> result 
         :out
         str/trim
         str/split-lines
         (map str/trim))))

(defn overrides-for-test
  [test-path]
  (let [[dir _] (f/split test-path)
        override-path (f/join dir "overrides.edn")]
    (when (os/exists? override-path)
      (-> override-path slurp read-string))))

(defn execute-test
  "Executes a single test; the test path is a file containing a transcript
   to feed into the game.  
  
  Returns nil on success and a failure map on failure."
  [build-data test-name test-path]
  (let [overrides (overrides-for-test test-path)
        build-data' (merge build-data overrides)
        sources (extract-sources build-data' false)
        test-input (->> test-path
                        slurp
                        str/split-lines
                        (remove str/blank?)
                        ;; Allow Dialog-style comments in the source transcript
                        (remove #(str/starts-with? % "%%"))
                        (str/join \newline))
        ;; TODO: Initialize random number generator?
        args (into ["-q" "-w" "80" "-L"]
                   sources)
        result (check-result "Test Execution"
                             (os/exec "dgdebug" {:args args
                                                 :stdin test-input}))
        actual-output (:out result)
        blessed-path (str "tests/" test-name ".out")
        expected-output (when (os/exists? blessed-path)
                          (slurp blessed-path))
        passed? (= actual-output expected-output)]
    (when-not passed?
      (let [output-path (str "out/failed-tests/" test-name ".out")
            [output-dir _] (f/split output-path)]
        (mkdirs output-dir)
        (spit output-path actual-output)
        {:test-name test-name
         :output-path output-path
         :blessed-path blessed-path}))))

(defn write-failures 
  [failures]
  (spit failures-path
        (with-out-str (pprint failures))))


(defn bless-test
  "Show diff for test, ask user to bless.

  If user approves, replace blessed file with output file, and return true.

  Otherwise, return false."
  [failure-map]
  (let [{:keys [test-name output-path blessed-path]} failure-map]
    ;; Its goint to fail (with 1) because the files are not the same
    (os/exec "colordiff" {:args ["-N" "-y" "-W" "170"
                                 "--left-column"
                                 blessed-path output-path]
                          :stdout *out*
                          :stderr *err*})
    (println)
    (loop []
      (print (str "Bless " test-name " differences (" green-font "right column" reset-font ")? [yN] "))
      (let [input (read-line)]
        (cond
          (= input "y")
          (do
            (check-result "Move file" (os/sh "mv" "-f" output-path blessed-path))
            true)

          (or (= input "")
              (= input "n"))
          false

          :else
          (do
            (println (str red-font "Enter 'y' or 'n' (or hit enter)" reset-font))
            (recur)))))))

(defn do-bless
  [failures]
  (let [f (fn [failures failure-map]
            (if (bless-test failure-map)
              failures
              (conj failures failure-map)))
        failures' (reduce f [] failures)]
    (if (seq failures')
      (write-failures failures')
      (rm failures-path))))

(defn 
  ^{:command true
    :command-name "test"
    :command-opts [["-b" "--bless" "Immediately bless changes if there are failures"]]}
  run-tests
  "Runs tests, capturing output, summarizing failures.

Any failures are recorded, for use by the bless command."
  [parsed-opts]
  (let [{:keys [options]} parsed-opts
        build-data (read-build-file)
        paths (find-test-paths)
        test-names (->> paths
                        (map #(str/replace % "tests/" ""))
                        (map #(str/replace % #"\.txt" ""))
                        sort)
        test-tuples (map vector test-names paths)
        max-width (apply max (map count test-names))
        f (fn [failures [test-name test-path]]
            (print (str/pad-left test-name " " max-width) "... ")
            (let [start-time (t/now)
                  failure (execute-test build-data test-name test-path)
                  elapsed (str/pad-left
                           (t/string (t/since start-time))
                           " " 18)]
              (if failure
                (do
                  (println (str red-font "X" reset-font) elapsed)
                  (conj failures failure))
                (do
                  (println (str green-font \u2713 reset-font) elapsed)
                  failures))))
        failures (reduce f [] test-tuples)]
    (mkdirs "out")
    (if (seq failures)
      (do
        (println (str "\n" red-font (count failures) " failures" reset-font))
        (if (:bless options)
          (do-bless failures)
          (write-failures failures)))
      (do
        (println (str "\n" green-font "OK" reset-font))
        (rm failures-path)))))

(defn ^:command
  bless
  "Review failed tests and bless those where the change is acceptable"
  [_]
  (when-not (os/exists? failures-path)
    (fail "No failed tests to bless"))
  (-> failures-path
      slurp
      read-string
      do-bless))

(defn ^{:command true
        :command-opts [["-o" "--overrides PATH" "Path to overrides for dialog.edn"]]}
  debug
  "Runs the game in Dialog debugger"
  [parsed-options]
  (let [{:keys [options]} parsed-options
        overrides-path (:overrides options)
        build-data (read-build-file)
        overrides (when overrides-path
                    (-> overrides-path 
                        slurp
                        read-string))
        build-data' (merge build-data overrides)
        sources (extract-sources build-data' true)]
    (os/exec "dgdebug" {:args sources
                        :stdin *in*
                        :stdout *out*
                        :stderr *err*})))

;; Main entry point.
(multi/dispatch {:tool-name "dgt"
                 :namespaces ['dgt]})