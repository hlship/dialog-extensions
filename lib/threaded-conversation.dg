%% Based on Threaded Conversation by Chris Connelly, et al.

%% I7 refers to the baseline implementation in Inform7

(extension version)
    Threaded Conversation 0.0.1

%% (quip $)
%% (one-time $) vs. (repeatable $)

@(one-time $Quip)     ~(repeatable $Quip)

%% Prevent warnings at startup:

(repeatable $Quip) (fail)
($ directly follows $) (fail)

%% (restrictive $) vs. (unrestrictive $)
%% (player directed $) vs. (npc-directed $)
%% (beat opened $) vs. (speech opened $)
%% (comment $) - PC's speech
%% (reply $) -- NPC's reply
%% (nag $) -- optional message, used with required quips
%% (name $) -- name, e.g, "about Lily"
%% (dict *) -- additional terms
%% ($Quip directly follows $PriorQuip) -- valid only immediately after $PriorQuip
%% ($Quip indirectly follows $PriorQuip) -- valid any time after $PriorQuip
%% ($Quip supplies $Actor) -- only valid with $Actor as conversation partner

@($Quip supplies anyone) ~($Quip supplies $)
    %% I7 calls this "universally-applicable" vs. "character tailored"

(quip $Quip)    *(questioning quip $Quip)   %% ask
(quip $Quip)    *(informative quip $Quip)   %% tell
(quip $Quip)    *(demonstrative quip $Quip) %% other

%% This is "current interlocutor" in I7:

(global variable (conversation partner $))

%% This are the quips available to the player, based on
%% the conversation partner, rebuilt on every tick.

(global variable (available quips $))

%% (global variable (current quip $))
%% (global variable (previous quip $))
%% (global variable (grandparent quip $))

%% quips are objects and related to other objects

%% ($Quip mentions $Subject)

%% Recollection of quips
%% When an quip is performed every nearby actor will recollect the quip

%% Dialog doesn't handle multi-valued properties.  So we have
%% a dynamic property ($Quip is recollected by $ActorList) and a rule
%% ($Actor recollects $Quip).

(make $Actor recollect $Quip)
    { ($Quip is recollected by $Actors) (or) ($Actors = []) }
    ~($Actor is one of $Actors)
    (now) ($Quip is recollected by [$Actor | $Actors])

@($Quip stands alone)   ~($Quip follows $)

%% I7 makes all directly follows also indirectly follows, but
%% don't think that is necessary.

($Quip follows $EarlierQuip)
    { ($Quip directly follows $EarlierQuip) (or)
      ($Quip indirectly follows $EarlierQuip) }

($Quip is valid for $NPC)
    { ($Quip supplies anyone) (or) ($Quip supplies $NPC) }
    { ($Quip stands alone)
        (or) *($Quip follows $EarlierQuip)
             ($NPC recollects $EarlierQuip)
            }
    { (repeatable $Quip) (or) ~($NPC recollects $Quip) }
    %% TODO: $Q directly follows $X means not valid unless $X is the
    %% most recent quip.

    %% TODO: Don't allow change of subject if the the quip is restrictive

%% We have the quip track who recollects it, which seems odd, but if the
%% actor tracks the recollected quips, then the #player will end up with
%% a potentially giant list. Ultimately, we may end up marking certain quips
%% as notable and worthy of recollection, to optimize all this.

($Actor recollects (quip $Quip))
    ($Quip is recollected by $Actors)
    ($Actor is one of $Actors)

%% Queuing of quips
%% The player talks, and a response is queued for the next tick
%% Sometimes, as a side effect of other quips (or other actions)
%% additional NPC-directed quips are queued as well.

%% Queue a quip for the NPC at precendence
%% precedences:
%% #immediate-obligatory - answer to player's question
%% #postponed-obligatory - important, survives change of subject
%% #postponed-optional - casual, cleared on change of subject
%% #immediate-optional - casual, cleared on any player comment

(queue $Quip for $NPC)
    (queue $Quip for $NPC as #immediate-obligatory)

(queue $Quip for $NPC as $Precedence)
    %% I7 just queues the quips and sets a quip property to identify
    %% how it is queued. That just doesn't feel right.
    { ($NPC has conversation queue $Queue) (or) ($Queue = []) }
    %% TODO: May need to ensure quip or tuple not already queued?
    (now) ($NPC has conversation queue [[$Precedence $Quip] | $Queue])
    
(extract next quip for $NPC as $Quip)
    %% TODO: Find first immediate obligatory, then (if not found) any other
    ($NPC has conversation queue $Queue)
    *($Tuple is one of $Queue)
    ($Tuple = [$ $Quip])
    (remove $Tuple from $Queue as $NewQueue)
    (now) ($NPC has conversation queue $NewQueue)

(on every tick)
    (conversation partner $NPC)
    (extract next quip for $NPC as $Quip)
    %% If found (and removed from queue) print the reply now
    %% TODO: Lots of logic from I7 about paragraph breaks, no talking heads, etc.
    (par)
    (reply $Quip)
    %% The player recollects it on the prior tick; the NPC
    %% recollects after the reply is produced.
    (make $NPC recollect $Quip)

($NPC has available quips $Quips)
    (collect $Quip)
        *(quip $Quip)
        ($Quip is valid for $NPC)
    (into $Quips)

(on every tick)
    (now) (available quips [])
    (conversation partner $Partner)
    ($Partner has available quips $Quips)
    (now) (available quips $Quips)

(on every tick)
    (available quips $Quips)
    ~(empty $Quips)
    (current player $Player)
    (collect $Action)
        *($Quip is one of $Quips)
        %% Never suggest to the player a quip they've already performed.
        ~($Player recollects $Quip)
        ($Action = [discuss $Quip])
    (into $Actions)
    (nonempty $Actions)
    (par)
    (categorize list $Actions by { (unlikely $_) } into $UnlikelyActions and $LikelyActions)
    %% Not sure this is what I7 does.  Essentially, if there only unlikely actions
    %% (such as repeating a recollected quip) then we'll list those, but if there are
    %% other likely quips, we list only the likely ones.
    (if) (empty $LikelyActions) (then)
        ($ReportableActions = $UnlikelyActions)
    (else)
        ($ReportableActions = $LikelyActions)
    (endif)
    You could (enumerate actions $ReportableActions).

(enumerate actions [$A1 $A2])
    (describe action $A1)
    , %% I'm an Oxford comma kind of guy
    or
    (describe action $A2)

(enumerate actions [$A])
    (describe action $A)

(enumerate actions [$A | $More])
    (describe action $A)
    ,
    (enumerate actions $More)

(rewrite [ask | $Words] into [ask | $TailWords])
    (split $Words by [about] into $Person and $MoreWords)
    (nonempty $Person)
    (nonempty $MoreWords)
    (append $Person $MoreWords $TailWords)

(understand [ask | $Text] as [discuss $Quip with $Person])
    *(split $Text anywhere into $Someone and $QuipWords)
    *(understand $Someone as single object $Person preferably animate)
    (animate $Person)
    (filter $QuipWords into $Filtered) 
    (nonempty $Filtered)
    (if) (conversation partner $Person) (then)
        %% If mid-conversation with someone, then the available quips were calculated
        %% at the start of the tick.
        (available quips $Quips)
    (else)
        %% This could get expensive if several words each identify the same NPC
        ($Person has available quips $Quips)
    (endif)
    *(understand $Filtered as quip $Quip from $Quips)
    (questioning quip $Quip)

(rewrite [ask about/whether $Text] into [ask $Text])

(understand [ask | $Text] as [discuss $Quip])
    (filter $Text into $Filtered)
    (nonempty $Filtered)
    (conversation partner $Partner)
    (available quips $Quips)
    *(understand $Text as quip $Quip from $Quips)
    (questioning quip $Quip)

(unlikely [ask $Someone])
    ~(animate $Someone)

%% Essentially, this is to change the current
%% conversation partner.

(perform [discuss $Quip with (conversation partner $)])
    (try [discuss $Quip])

(perform [discuss $Quip with $Person])
    (try [talk to $Person])
    (try [discuss $Quip])

%% This is the real discuss, where we knew the NPC before understanding the
%% command, so we know the quip is valid for that NPC.

(prevent [discuss $Quip])
    (conversation partner $Partner)
    ~($Quip is valid for $Partner)
    (when $Quip is not a topic)

(perform [talk to $Person])
    (now) (conversation partner $Person)
    (narrate $Person greeting)  %% Doesn't look like I7 version quite does this?
    (notice $Person)

(narrate $Person greeting)
    You say hello to (the $Person).
    (par)
    
%% Take 1: The words identify the quip by dict name

(understand $Words as quip $Quip from $Quips)
    (determine object $Quip)
        *($Quip is one of $Quips)
    (from words)
        *(dict $Quip)
    (matching all of $Words)

%% Take 2: understand quips that mention a topic that matches the words
%% This also works with quips that mention objects (that are in scope).
%% This also understands 'it' as an object that is mentioned by a quip.

(understand $Words as quip $Quip from $Quips)
    *(understand $Words as topic $Topic)
    *($Quip is one of $Quips)
    ($Quip mentions $Topic)

%% By default, the standard library ensures that any objects identified
%% in an action list are in scope; quips are like topics, abstract,
%% so these two negated predicates disable that check when discussing.

~(refuse [discuss $ with $])
~(refuse [discuss $])


%% This rule prevents this odd exchange:
%% > ask maid where
%% Did you want to:
%% 1. discuss the where does Garrick live with the Bar Maid,
%% 2. discuss the where the Bar Maid comes from with the Bar Maid, or
%% 3. asking where the Bar Maid comes from?
%%
%% Though we could clean that all up and hopefully avoid
%% that ambiguity by some other means.

(unlikely [discuss $ with $])
    %% May need to be adjusted to only when the CP matches
    %% the actor.
    (conversation partner $)

(unlikely [discuss $Quip])
    (conversation partner $Partner)
    (repeatable $Quip)
    ($Partner recollects $Quip)

(prevent [discuss $Quip])
    ~(conversation partner $)
    We're not talking to anyone right now.

(perform [discuss $Quip])
    (narrate discussing $Quip)
    %% TODO: Maybe a predicate to allow reactions to the player's side of the quip
    (current player $Player)
    (make $Player recollect $Quip)

(describe action [discuss (questioning quip $Quip)])
    ask (name $Quip)
 
(when $ is not a topic)
    That doesn't seem to be a topic of conversation currently.

(narrate discussing $Quip)
    (conversation partner $NPC)
    (comment $Quip)
    (queue $Quip for $NPC as #immediate-obligatory)

%%
%% Utilities
%%

(categorize list [$Element | $More] by $Predicate into $Matches and $NonMatches)
    (if) (query $Predicate $Element) (then)
        ($Matches = [$Element | $MoreMatches])
        (categorize list $More by $Predicate into $MoreMatches and $NonMatches)
    (else)
        ($NonMatches = [$Element | $MoreNonMatches])
        (categorize list $More by $Predicate into $Matches and $MoreNonMatches)
    (endif)

(categorize list [] by $ into $Matches and $NonMatches)
    ($Matches = [])
    ($NonMatches = [])

(remove $Value from $List as $NewList)
    (collect $Term)
        *($Term is one of $List)
        ~($Term = $Value)
    (into $NewList)
