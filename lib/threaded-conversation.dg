%% Based on Threaded Conversation by Chris Connelly, et al.

%% I7 refers to the baseline implementation in Inform7

(extension version)
    Threaded Conversation 0.0.1


%% There are three types of player-directed quips.

(quip $Quip)    *(questioning quip $Quip)   %% ask
(quip $Quip)    *(informative quip $Quip)   %% say/tell
(quip $Quip)    *(performative quip $Quip)  %% other

%% NPC-directed quips (currently) are just objects.  Not even (quip $).
%% They just have a (reply $) and other quips may follow them.

%% (comment $) - PC's speech
%% (reply $) -- NPC's reply
%% (nag $) -- optional message, mostly used with restrictive quips
%% (beat $) -- 
%% (name $) -- name, e.g, "about Lily"
%% (dict *) -- additional terms

%% Quips are usually one time (per NPC) but can be repeatable instead.

@(one-time $Quip)     ~(repeatable $Quip)

%% Quips are usually available; a quip that is off limits is simply treated
%% as if it does not exist. This is not the final word, as quips may be
%% filtered down based on other factors, such as following prior quips,
%% repeatablilty etc.

@(available $Quip)   ~(off limits $Quip)

%% Most quips are unrestrictive (the player may change the subject).
%% Restrictive quips enforce that the next player quip must directly follow
%% the current quip.

@(unrestrictive $Quip)   ~(restrictive $Quip)

%% Quips are normally plausible, but dubious clips are allowed.
%% You have to be specific to choose an dubious quip, normally
%% all dubious quips are discarded if any plausible quips match.

@(plausible $Quip)   ~(dubious $Quip)

%% Prevent warnings at startup:

(repeatable $) (fail)
($ directly follows $) (fail)
(restrictive $) (fail)
(questioning quip $) (fail)
(informative quip $) (fail)
(performative quip $) (fail)
($ supplies $) (fail)
($ follows $) (fail)
(reply $) (fail)
($ mentions $) (fail)
(nag $) (fail)
(off limits $) (fail)
(dubious $) (fail)


%% (player directed $) vs. (npc-directed $)
%% (beat opened $) vs. (speech opened $)

%% ($Quip follows $PriorQuip) -- valid any time after $PriorQuip
%% ($Quip directly follows $PriorQuip) -- valid only immediately after $PriorQuip
%% ($Quip supplies $Actor) -- only valid with $Actor as conversation partner
%% A quip may supply multiple actors.  If it supplies none, then it is valid with any
%% conversation partner.

@($Quip supplies anyone) ~($Quip supplies $)
    %% I7 calls this "universally-applicable" vs. "character tailored"

%% Make sure the quip name is not prefixed with 'the' in disambiguation
(proper (quip $))

%% This is "current interlocutor" in I7:

(global variable (conversation partner $))

%% This are the quips available to the player, based on
%% the conversation partner, rebuilt on every tick.

(global variable (available quips $))

%% The most recently quip for which the comment or reply has been discussed.

(global variable (current quip $))

%% After an NPC performs their part of a comment/reply (via the NPC's queue)
%% the current quip becomes the previous quip.

(global variable (previous quip $))

%% Set when the discussed quip represents a change in subject

(global variable (grandparent quip $))

%% Used to vary the text when a quip immediately follows its prior quip.
%% If the player goes off on a tangent before returning to this quip,
%% then (immediately) will fail.
(immediately)
    (current quip $Current)
    (previous quip $Previous)
    ($Current follows $Previous)

%% (global variable (grandparent quip $))

%% quips are objects and related to other objects

%% ($Quip mentions $Subject)

%% Recollection of quips
%% When the player's comment is printed, the player will recollect the quip
%% When the NPC's reply is printed, the NPC will recollect the quip
%% TODO: Currently, a queued quip may not have a comment, and the player will
%% not recollect the quip even though the NPC does.

%% Dialog doesn't handle multi-valued properties.  So we have
%% a dynamic property ($Quip is recollected by $ActorList) and a rule
%% ($Actor recollects $Quip).

(make $Actor recollect $Quip)
    { ($Quip is recollected by $Actors) (or) ($Actors = []) }
    ~($Actor is one of $Actors)
    (now) ($Quip is recollected by [$Actor | $Actors])

%% We have the quip track who recollects it, which seems odd, but if the
%% actor tracks the recollected quips, then the #player will end up with
%% a potentially giant list. Ultimately, we may end up marking certain quips
%% as notable and worthy of recollection, to optimize all this.

($Actor recollects (quip $Quip))
    ($Quip is recollected by $Actors)
    ($Actor is one of $Actors)

%% Rules for quips, threads, availablility, etc.

@($Quip stands alone)   ~($Quip continues from $)

@($Quip is dead ended)  ~($ continues from $Quip)

@($Quip is mid thread)
    ~($Quip stands alone)
    ~($Quip is dead ended)

%% I7 makes all directly follows also follows, but
%% don't think that is necessary.

($Quip continues from $EarlierQuip)
    { ($Quip directly follows $EarlierQuip) (or)
      ($Quip follows $EarlierQuip) }

($Quip is valid for $NPC)
    (available $Quip)
    { ($Quip supplies anyone) (or) ($Quip supplies $NPC) }
    { ($Quip stands alone)
        (or) *($Quip follows $EarlierQuip)
             ($NPC recollects $EarlierQuip)
        (or) (current quip $CurrentQuip) %% Player *just* discussed it
             ($Quip directly follows $CurrentQuip)
    }
    %% Watch out for on-time quips that this NPC has already performed
    { (repeatable $Quip) (or) ~($NPC recollects $Quip) }
    %% Guard against changing the subject during
    %% a restrictive qup
    (if) (current quip $CurrentQuip)
         (restrictive $CurrentQuip)
    (then) ($Quip directly follows $CurrentQuip)
    (endif)

%% Queuing of quips
%% The player talks, and a response is queued for the next tick
%% Sometimes, as a side effect of other quips (or other actions)
%% additional NPC-directed quips are queued as well.

%% Queue a quip for the NPC at precendence
%% precedences:
%% #immediate-obligatory - answer to player's question
%% #postponed-obligatory - important, survives change of subject
%% #postponed-optional - casual, cleared on change of subject
%% #immediate-optional - casual, cleared on any player comment

(queue $Quip for $NPC)
    (queue $Quip for $NPC as #immediate-obligatory)

(queue $Quip for $NPC as $Precedence)
    %% I7 just queues the quips and sets a quip property to identify
    %% how it is queued. That just doesn't feel right.
    { ($NPC has conversation queue $Queue) (or) ($Queue = []) }
    %% TODO: May need to ensure quip or tuple not already queued?
    (now) ($NPC has conversation queue [[$Precedence $Quip] | $Queue])
    
(extract next quip for $NPC as $Quip)
    ($NPC has conversation queue $Queue)
    *($Tuple is one of $Queue)
    ($Tuple = [$ $Quip])
    (remove $Tuple from $Queue as $NewQueue)
    (now) ($NPC has conversation queue $NewQueue)

(purge conversation queue for $NPC)
    (now) ~($NPC has conversation queue)

(purge $Precendence from conversation queue for $NPC)
    ($NPC has conversation queue $OldQueue)
    (collect $Tuple)
        ($Tuple is one of $OldQueue)
        ~($Tuple = [$Precedence $])
    (into $NewQueue)
    (now) ($NPC has conversation queue $NewQueue)

(record current quip $Quip)
    %% This gets called just before the player's comment, then again
    %% just before the NCPs reply.  Have to check that we don't overdo it.
    (if) ~(current quip $Quip) 
    (then)
        (if) (current quip $Previous)
        (then)
            (now) (previous quip $Previous)
        (endif)
        (now) (current quip $Quip)
    (endif)

%% Handle the reply to the PC's comment
(on every tick)
    %% TODO: Could be multiple NPCs ready to chat!
    (conversation partner $NPC)
    (perform queued quip for $NPC)

(perform queued quip for $NPC)
    (extract next quip for $NPC as $Quip)
    %% If found (and removed from queue) print the reply now
    %% TODO: Lots of logic from I7 about paragraph breaks, no talking heads, etc.
    (par)
    (record current quip $Quip)
    (reply $Quip)
    %% The player recollects it on the prior tick; the NPC
    %% recollects after the reply is produced.
    (make $NPC recollect $Quip)
    %% TODO: A queued quip may not be recollected by the player!
    %% This may have been a queued quip, it is now the current quip
    %% which will affect quip availability.

%% Here was allow NPCs to, perhaps, speak something from their queue
(on every tick)
    (conversation partner $NPC)
    %% TODO: Perhaps alternate check for 'no current quip'?
    (current quip $Quip)
    ($Quip is dead ended)
    %% TODO: I7's "avoid talking heads activity"
    (perform queued quip for $NPC)

(change subject to $Quip)
    (now) (grandparent quip $Quip)

%% Identifying available quips
%%
%% As an optimization, at the start of each tick, the possible available quips
%% (based on conversations partner, current quip, thread of converstation, etc.)
%% is identified and stored in the (available quips $List) global.
%% Some of these quips may be dubious or represent a change of subject, in which case
%% they are unlikely (but still possible), but only likely (e.g., continuations of
%% the current thread) are ever suggested to the player.

($NPC has available quips $Quips)
    (collect $Quip)
        *(quip $Quip)
        ($Quip is valid for $NPC)
    (into $Quips)

%% Identify which quips (even if dubious or unlikely) are available for the current NPC
%% for the player to select.

(on every tick)
    (rebuild available quips)

(rebuild available quips)
    (now) (available quips [])
    (conversation partner $NPC)
    ($NPC has available quips $Quips)
    (now) (available quips $Quips)

%% Identify likely quips; nothing dubious and nothing unlikely (generally, switching out of the current thread).

(on every tick)
    (available quips $Quips)
    ~(empty $Quips)
    (current player $Player)
    (collect $Action)
        *($Quip is one of $Quips)
        %% Never suggest to the player a quip they've already performed.
        ~($Player recollects $Quip)
        ($Action = [discuss $Quip])
        %% Only interested in likely actions -- this excludes quips that are dubious, or change the current thread (if any).
        ~(unlikely $Action)
    (into $Actions)
    (nonempty $Actions)
    (par)
    You could 
    (listing $Actions { (describe action $_) } @or 0)
    .

%% Unlikely helps weed out non-relevant quips, and is tied into the
%% "You could ..." every tick rules.
(unlikely [discuss $Quip])
    (current quip $Current)
    ($Current is mid thread)
    ~($Quip continues from $Current)

%% All dubious quips are unlikely actions; this again keeps
%% them from being suggested.

(unlikely [discuss $Quip])
    (dubious $Quip)
 
%% Repeatable quips can be returned to, but are unlikely, so they are never
%% suggested.

(unlikely [discuss $Quip])
    (repeatable $Quip)
    (current player $Player)
    ($Player recollects $Quip)

(rewrite [a/ask | $Words] into [ask | $TailWords])
    (split $Words by [about] into $Person and $MoreWords)
    (nonempty $Person)
    (nonempty $MoreWords)
    (append $Person $MoreWords $TailWords)

(understand [a/ask | $Text] as [discuss $Quip with $Person])
    *(understand $Text as $Quip with $Person)
    (questioning quip $Quip)

(understand [say | $Text] as [discuss $Quip with $Person])
    *(understand $Text as $Quip with $Person)
    (informative quip $Quip)

(understand $Text as $Quip with $Person)
    *(split $Text anywhere into $Someone and $QuipWords)
    *(understand $Someone as single object $Person)
    %% Using `preferably animate` above caused some odd disambiguation errors
    (animate $Person)
    *(understand $QuipWords as quip $Quip for $Person)

(rewrite [a/ask about/whether $Text] into [ask $Text])

(understand [a/ask | $Text] as [discuss $Quip])
    (conversation partner $Partner)
    *(understand $Text as quip $Quip for $Partner)
    (questioning quip $Quip)

(understand [say/tell | $Text] as [discuss $Quip])
    (conversation partner $Partner)
    *(understand $Text as quip $Quip for $Partner)
    (informative quip $Quip)

%% Mostly, this is to support demonstrative quips, but it also works for the other two kinds.
%% But if nothing matches, don't understand at all, to get to normal failure message.
(understand $Text as [discuss $Quip])
    (conversation partner $Partner)
    *(understand $Text as quip $Quip for $Partner)

(understand $Text as quip $Quip for $Person)
    (filter $Text into $Filtered)
    (nonempty $Filtered)
    (if) (conversation partner $Person) (then)
        %% If mid-conversation with someone, then the available quips were calculated
        %% at the start of the tick.
        (available quips $Quips)
    (else)
        %% This could get expensive to keep recalculating if several words each identify the same NPC
        ($Person has available quips $Quips)
    (endif)    
    *(understand $Text as quip $Quip from $Quips)

(unlikely [ask/tell $Someone])
    ~(animate $Someone)

%% Essentially, this is to change the current
%% conversation partner.

(perform [discuss $Quip with (conversation partner $)])
    (try [discuss $Quip])

(perform [discuss $Quip with $Person])
    (try [talk to $Person])  %% Maybe should be a before rule?
    (try [discuss $Quip])

%% This is the real discuss, where we knew the NPC before understanding the
%% command, so we know the quip is valid for that NPC.

(perform [talk to $Person])
    (now) (conversation partner $Person)
    (narrate greeting $Person)  %% Doesn't look like I7 version quite does this?
    (notice $Person)

(narrate greeting $Person)
    You say hello to (the $Person).
    (par)
    
%% Take 1: The words identify the quip by dict name

(understand $Words as quip $Quip from $Quips)
    (determine object $Quip)
        *($Quip is one of $Quips)
    (from words)
        *(dict $Quip)
    (matching all of $Words)

%% Take 2: understand quips that mention a topic that matches the words

(understand $Words as quip $Quip from $Quips)
    *(understand $Words as topic $Topic)
    *($Quip is one of $Quips)
    ($Quip mentions $Topic)

%% Take 3: understand quips that mention an object (which doesn't have to be in scope)
%% This should also work with topic objects.

(understand $Words as quip $Quip from $Quips)
    *($Quip is one of $Quips)
    (determine object $Mention)
        *($Quip mentions $Mention)
        (object $Mention)
    (from words)
        *(dict $Mention)
    (matching all of $Words)

%% By default, the standard library ensures that any objects identified
%% in an action list are in scope; quips are like topics, abstract,
%% so these two negated predicates disable that check when discussing.

~(refuse [discuss $ with $])
~(refuse [discuss $])

%% This rule prevents this odd exchange:
%% > ask maid where
%% Did you want to:
%% 1. discuss the where does Garrick live with the Bar Maid,
%% 2. discuss the where the Bar Maid comes from with the Bar Maid, or
%% 3. asking where the Bar Maid comes from?
%%
%% Though we could clean that all up and hopefully avoid
%% that ambiguity by some other means.

(unlikely [discuss $ with $])
    %% May need to be adjusted to only when the CP matches
    %% the actor.
    (conversation partner $)

(unlikely [discuss $Quip])
    (conversation partner $Partner)
    (repeatable $Quip)
    ($Partner recollects $Quip)

(prevent [discuss $Quip])
    ~(conversation partner $)
    We're not talking to anyone right now.

(perform [discuss $Quip])
    %% Record the quip as the current quip now, which ensures that the
    %% (immediately) predicate operates correctly.
    (record current quip $Quip)
    (comment $Quip)
    %% TODO: Maybe a predicate to allow reactions to the player's side of the quip
    (current player $Player)
    (make $Player recollect $Quip)
    (conversation partner $NPC)
    (queue $Quip for $NPC as #immediate-obligatory)

(describe action [discuss (questioning quip $Quip)])
    (if) (library links enabled) (then)
        (collect words)
            (name $Quip)
        (into $Words)
        (link [ask | $Words]) { ask (name $Quip) }
    (else)
        ask (name $Quip)
    (endif)

(describe action [discuss (informative quip $Quip)])
    (if) (library links enabled) (then)
        (collect words)
            (name $Quip)
        (into $Words)
        (link [say | $Words]) { say (name $Quip) }
    (else)
        say (name $Quip)
    (endif)

(describe action [discuss (performative quip $Quip)])
    (if) (library links enabled) (then)
        (collect words)
            (name $Quip)
        (into $Words)
        (link $Words) { (name $Quip) }
    (else)
        (name $Quip)
    (endif)
 
%% When the player does anything but discuss a quip when there's a quip hanging
%% properly, output the nag.
(perform [$verb | $])
    ~($verb = @discuss)
    (current quip $Quip)
    %% You'll almost always want a nag to start with `(beat *)`.
    %% An attempt to collect the output from nag and do the beat automatically
    %% didn't work ... text came out all lower case, or each word capitalized.
    (nag $Quip)
    (par)
    (fail)

%% A beat is used to break up quips and such. Excellent chance to provide
%% some varied, quip-specific output.

(beat $)
    A moment passes.
    (par)

%% This is not currently used because the logic for changing "I don't understand" is hard to override.
%% (when not a topic of conversation)
%%     That doesn't seem to be a topic of conversation at the moment.
 
%%
%% Utilities
%%

%% Some of these are not used and may go away

(remove $Value from $List as $NewList)
    (collect $Term)
        *($Term is one of $List)
        ~($Term = $Value)
    (into $NewList)
