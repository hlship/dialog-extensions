%% Based on Threaded Conversation by Chris Connelly, et al.

%% I7 refers to the baseline implementation in Inform7

(extension version)
    Threaded Conversation 0.0.1

%% (quip $)
%% (one-time $) vs. (repeatable $)

@(one-time $Quip)     ~(repeatable $Quip)

%% Prevent warnings at startup:

(repeatable $) (fail)
($ directly follows $) (fail)
(restrictive $) (fail)
(questioning quip $) (fail)
(informative quip $) (fail)
(performative quip $) (fail)
($ supplies $) (fail)
($ indirectly follows $) (fail)
(reply $) (fail)
($ mentions $) (fail)
(nag $) (fail)


%% (restrictive $) vs. (unrestrictive $)
%% (player directed $) vs. (npc-directed $)
%% (beat opened $) vs. (speech opened $)
%% (comment $) - PC's speech
%% (reply $) -- NPC's reply
%% (nag $) -- optional message, mostly used with restrictive quips
%% (beat $) -- 
%% (name $) -- name, e.g, "about Lily"
%% (dict *) -- additional terms
%% ($Quip directly follows $PriorQuip) -- valid only immediately after $PriorQuip
%% ($Quip indirectly follows $PriorQuip) -- valid any time after $PriorQuip
%% ($Quip supplies $Actor) -- only valid with $Actor as conversation partner

@(unrestrictive $Quip)   ~(restrictive $Quip)
@($Quip supplies anyone) ~($Quip supplies $)
    %% I7 calls this "universally-applicable" vs. "character tailored"

(quip $Quip)    *(questioning quip $Quip)   %% ask
(quip $Quip)    *(informative quip $Quip)   %% say/tell
(quip $Quip)    *(performative quip $Quip)  %% other

%% This is "current interlocutor" in I7:

(global variable (conversation partner $))

%% This are the quips available to the player, based on
%% the conversation partner, rebuilt on every tick.

(global variable (available quips $))

(global variable (current quip $))

%% (global variable (previous quip $))
%% (global variable (grandparent quip $))

%% quips are objects and related to other objects

%% ($Quip mentions $Subject)

%% Recollection of quips
%% When the player's comment is printed, the player will recollect the quip
%% When the NPC's reply is printed, the NPC will recollect the quip
%% TODO: Currently, a queued quip may not have a comment, and the player will
%% not recollect the quip even though the NPC does.

%% Dialog doesn't handle multi-valued properties.  So we have
%% a dynamic property ($Quip is recollected by $ActorList) and a rule
%% ($Actor recollects $Quip).

(make $Actor recollect $Quip)
    { ($Quip is recollected by $Actors) (or) ($Actors = []) }
    ~($Actor is one of $Actors)
    (now) ($Quip is recollected by [$Actor | $Actors])

%% We have the quip track who recollects it, which seems odd, but if the
%% actor tracks the recollected quips, then the #player will end up with
%% a potentially giant list. Ultimately, we may end up marking certain quips
%% as notable and worthy of recollection, to optimize all this.

($Actor recollects (quip $Quip))
    ($Quip is recollected by $Actors)
    ($Actor is one of $Actors)

%% Rules for quips, threads, availablility, etc.

@($Quip stands alone)   ~($Quip follows $)

@($Quip is dead ended)  ~($ follows $Quip)

@($Quip is mid thread)
    ~($Quip stands alone)
    ~($Quip is dead ended)

%% I7 makes all directly follows also indirectly follows, but
%% don't think that is necessary.

($Quip follows $EarlierQuip)
    { ($Quip directly follows $EarlierQuip) (or)
      ($Quip indirectly follows $EarlierQuip) }

($Quip is valid for $NPC)
    { ($Quip supplies anyone) (or) ($Quip supplies $NPC) }
    { ($Quip stands alone)
        (or) *($Quip indirectly follows $EarlierQuip)
             ($NPC recollects $EarlierQuip)
        (or) (current quip $CurrentQuip) %% Player *just* discussed it
             ($Quip directly follows $CurrentQuip)
    }
    { (repeatable $Quip) (or) ~($NPC recollects $Quip) }
    %% This should guard against changing the subject
    (if) (current quip $CurrentQuip)
         (restrictive $CurrentQuip)
    (then) ($Quip directly follows $CurrentQuip)
    (endif)

%% Queuing of quips
%% The player talks, and a response is queued for the next tick
%% Sometimes, as a side effect of other quips (or other actions)
%% additional NPC-directed quips are queued as well.

%% Queue a quip for the NPC at precendence
%% precedences:
%% #immediate-obligatory - answer to player's question
%% #postponed-obligatory - important, survives change of subject
%% #postponed-optional - casual, cleared on change of subject
%% #immediate-optional - casual, cleared on any player comment

(queue $Quip for $NPC)
    (queue $Quip for $NPC as #immediate-obligatory)

(queue $Quip for $NPC as $Precedence)
    %% I7 just queues the quips and sets a quip property to identify
    %% how it is queued. That just doesn't feel right.
    { ($NPC has conversation queue $Queue) (or) ($Queue = []) }
    %% TODO: May need to ensure quip or tuple not already queued?
    (now) ($NPC has conversation queue [[$Precedence $Quip] | $Queue])
    
(extract next quip for $NPC as $Quip)
    %% TODO: Find first immediate obligatory, then (if not found) any other
    ($NPC has conversation queue $Queue)
    *($Tuple is one of $Queue)
    ($Tuple = [$ $Quip])
    (remove $Tuple from $Queue as $NewQueue)
    (now) ($NPC has conversation queue $NewQueue)

(on every tick)
    (conversation partner $NPC)
    (extract next quip for $NPC as $Quip)
    %% If found (and removed from queue) print the reply now
    %% TODO: Lots of logic from I7 about paragraph breaks, no talking heads, etc.
    (par)
    (reply $Quip)
    %% The player recollects it on the prior tick; the NPC
    %% recollects after the reply is produced.
    (make $NPC recollect $Quip)
    %% TODO: A queued quip may not be recollected by the player!
    %% This may have been a queued quip, it is now the current quip
    %% which will affect quip availability.
    (now) (current quip $Quip)

($NPC has available quips $Quips)
    (collect $Quip)
        *(quip $Quip)
        ($Quip is valid for $NPC)
    (into $Quips)

(on every tick)
    (now) (available quips [])
    (conversation partner $Partner)
    ($Partner has available quips $Quips)
    (now) (available quips $Quips)

(on every tick)
    (available quips $Quips)
    ~(empty $Quips)
    (current player $Player)
    (collect $Action)
        *($Quip is one of $Quips)
        %% Never suggest to the player a quip they've already performed.
        ~($Player recollects $Quip)
        ($Action = [discuss $Quip])
        %% Only interested in likely actions
        ~(unlikely $Action)
    (into $Actions)
    (nonempty $Actions)
    (par)
    You could (enumerate actions $Actions).

(enumerate actions [$A1 $A2])
    (describe action $A1)
    , %% I'm an Oxford comma kind of guy
    or
    (describe action $A2)

(enumerate actions [$A])
    (describe action $A)

(enumerate actions [$A | $More])
    (describe action $A)
    ,
    (enumerate actions $More)

%% Unlikely helps weed out non-relevant quips, and is tied into the
%% "You could ..." every tick rules.
(unlikely [discuss $Quip])
    (current quip $Current)
    ($Current is mid thread)
    ~($Quip follows $Current)
 
%% Repeatable quips can be returned to, but are unlikely, so they are never
%% suggested.

(unlikely [discuss $Quip])
    (repeatable $Quip)
    (current player $Player)
    ($Player recollects $Quip)

(rewrite [a/ask | $Words] into [ask | $TailWords])
    (split $Words by [about] into $Person and $MoreWords)
    (nonempty $Person)
    (nonempty $MoreWords)
    (append $Person $MoreWords $TailWords)

(understand [a/ask | $Text] as [discuss $Quip with $Person])
    *(understand $Text as $Quip with $Person)
    (questioning quip $Quip)

(understand [say | $Text] as [discuss $Quip with $Person])
    *(understand $Text as $Quip with $Person)
    (informative quip $Quip)

(understand $Text as $Quip with $Person)
    *(split $Text anywhere into $Someone and $QuipWords)
    *(understand $Someone as single object $Person preferably animate)
    %% No, we really mean animate. Was getting odd disambiguiting prompts like
    %% "Do you mean to ask the miniature something?"
    (animate $Person)
    *(understand $QuipWords as quip $Quip for $Person)

(rewrite [ask about/whether $Text] into [ask $Text])

(understand [a/ask | $Text] as [discuss $Quip])
    (conversation partner $Partner)
    *(understand $Text as quip $Quip for $Partner)
    (questioning quip $Quip)

(understand [say/tell | $Text] as [discuss $Quip])
    (conversation partner $Partner)
    *(understand $Text as quip $Quip for $Partner)
    (informative quip $Quip)

(understand $Text as [discuss $Quip])
    (conversation partner $Partner)
    *(understand $Text as quip $Quip for $Partner)

(understand $Text as quip $Quip for $Person)
    (filter $Text into $Filtered)
    (nonempty $Filtered)
    (if) (conversation partner $Person) (then)
        %% If mid-conversation with someone, then the available quips were calculated
        %% at the start of the tick.
        (available quips $Quips)
    (else)
        %% This could get expensive if several words each identify the same NPC
        ($Person has available quips $Quips)
    (endif)    
    *(understand $Text as quip $Quip from $Quips)

(unlikely [ask $Someone])
    ~(animate $Someone)

%% Essentially, this is to change the current
%% conversation partner.

(perform [discuss $Quip with (conversation partner $)])
    (try [discuss $Quip])

(perform [discuss $Quip with $Person])
    (try [talk to $Person])  %% Maybe should be a before rule?
    (try [discuss $Quip])

%% This is the real discuss, where we knew the NPC before understanding the
%% command, so we know the quip is valid for that NPC.

(prevent [discuss $Quip])
    (conversation partner $Partner)
    ~($Quip is valid for $Partner)
    (when $Quip is not a topic)  %% Not sure this is reachable now

(perform [talk to $Person])
    (now) (conversation partner $Person)
    (narrate $Person greeting)  %% Doesn't look like I7 version quite does this?
    (notice $Person)

(narrate $Person greeting)
    You say hello to (the $Person).
    (par)
    
%% Take 1: The words identify the quip by dict name

(understand $Words as quip $Quip from $Quips)
    (determine object $Quip)
        *($Quip is one of $Quips)
    (from words)
        *(dict $Quip)
    (matching all of $Words)

%% Take 2: understand quips that mention a topic that matches the words

(understand $Words as quip $Quip from $Quips)
    *(understand $Words as topic $Topic)
    *($Quip is one of $Quips)
    ($Quip mentions $Topic)

%% Take 3: understand quips that mention an object (which doesn't have to be in scope)

(understand $Words as quip $Quip from $Quips)
    *($Quip is one of $Quips)
    (determine object $Mention)
        *($Quip mentions $Mention)
        (object $Mention)
    (from words)
        *(dict $Mention)
    (matching all of $Words)

%% By default, the standard library ensures that any objects identified
%% in an action list are in scope; quips are like topics, abstract,
%% so these two negated predicates disable that check when discussing.

~(refuse [discuss $ with $])
~(refuse [discuss $])


%% This rule prevents this odd exchange:
%% > ask maid where
%% Did you want to:
%% 1. discuss the where does Garrick live with the Bar Maid,
%% 2. discuss the where the Bar Maid comes from with the Bar Maid, or
%% 3. asking where the Bar Maid comes from?
%%
%% Though we could clean that all up and hopefully avoid
%% that ambiguity by some other means.

(unlikely [discuss $ with $])
    %% May need to be adjusted to only when the CP matches
    %% the actor.
    (conversation partner $)

(unlikely [discuss $Quip])
    (conversation partner $Partner)
    (repeatable $Quip)
    ($Partner recollects $Quip)

(prevent [discuss $Quip])
    ~(conversation partner $)
    We're not talking to anyone right now.

(perform [discuss $Quip])
    (narrate discussing $Quip)
    %% TODO: Maybe a predicate to allow reactions to the player's side of the quip
    (current player $Player)
    (make $Player recollect $Quip)
    (conversation partner $NPC)
    (queue $Quip for $NPC as #immediate-obligatory)
    (now) (current quip $Quip)

(describe action [discuss (questioning quip $Quip)])
    ask (name $Quip)

(describe action [discuss (informative quip $Quip)])
    say (name $Quip)

(describe action [discuss (performative quip $Quip)])
    (name $Quip)
 
(when $ is not a topic)
    That doesn't seem to be a topic of conversation currently.

(narrate discussing $Quip)
    (comment $Quip)

%% When the player does anything but discuss a quip when there's a quip hanging
%% properly, output the nag.
(perform [$verb | $])
    ~($verb = @discuss)
    (current quip $Quip)
    %% You'll almost always want a nag to start with `(beat $)`.
    %% An attempt to collect the output from nag and do the beat automatically
    %% didn't work ... text came out all lower case, or each word capitalized.
    (nag $Quip)
    (par)
    (fail)

%% A beat is used to break up quips and such. Excellent chance to provide
%% some varied, quip-specific output.

(beat $)
    A moment passes.
    (par)


%%
%% Utilities
%%

(categorize list [$Element | $More] by $Predicate into $Matches and $NonMatches)
    (if) (query $Predicate $Element) (then)
        ($Matches = [$Element | $MoreMatches])
        (categorize list $More by $Predicate into $MoreMatches and $NonMatches)
    (else)
        ($NonMatches = [$Element | $MoreNonMatches])
        (categorize list $More by $Predicate into $Matches and $MoreNonMatches)
    (endif)

(categorize list [] by $ into $Matches and $NonMatches)
    ($Matches = [])
    ($NonMatches = [])

(remove $Value from $List as $NewList)
    (collect $Term)
        *($Term is one of $List)
        ~($Term = $Value)
    (into $NewList)
